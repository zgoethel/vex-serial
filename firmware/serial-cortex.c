#pragma config(UART_Usage, UART2, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(Sensor, dgtl10, green,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, yellow,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, red,            sensorLEDtoVCC)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ANALOG_COUNT                8
#define ANALOG_START                0

#define DIGITAL_COUNT               12
#define DIGITAL_START               dgtl1

#define MOTOR_COUNT                 10
#define MOTOR_START                 0

#define CMD_END                     ';'
#define CMD_SPLIT                   ','
#define MSG_END                     '\n'
#define CMD_WRITE_ANALOG            'A'
#define CMD_WRITE_DIGITAL           'D'
#define CMD_WRITE_MOTOR             'M'

long sensorValues   [48] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
long motors         [10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0       };
byte commandBuffer  [24] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
byte argBuffer      [6]	 = { 0, 0, 0, 0, 0, 0                   };

long errorTime = 0;
int commandPointer = 0;

void sit() {}

void writeChar(char c)
{
	sendChar(uartTwo, c);
	while (!bXmitComplete(uartOne)) sit();
}

void writeChars(char* c)
{
	string s;
	stringFromChars(s, c);

	for (int i = 0; i < strlen(s); i ++)
		writeChar(stringGetChar(s, i));
}

void writeLine(char* c)
{
	writeChars(c);
	writeChar('\n');
}

void writeSensorUpdate(char* name, long* arr, int s, int c)
{
	writeChars(name);
	writeChars("Update:");
	for (int i = s; i < s + c; i ++)
		writeChar(arr[i]);
	writeLine(";");
}

task SendSensorValues()
{
	while (true)
	{
		for (int i = 0; i < 48; i ++)
			sensorValues[i] = SensorValue[i];
		writeSensorUpdate("Analog", &sensorValues[0], ANALOG_START, ANALOG_COUNT);
		writeSensorUpdate("Digital", &sensorValues[0], DIGITAL_START, DIGITAL_COUNT);
		for (int i = 0; i < 10; i ++)
			motors[i] = motor[i];
		writeSensorUpdate("Motor", motors, MOTOR_START, MOTOR_COUNT);
		wait1Msec(20);
	}
}

void commitWrite(byte typeId, byte pinId, byte writeVal)
{
	switch (typeId)
	{
	case CMD_WRITE_DIGITAL:
		SensorValue[dgtl1 + pinId] = writeVal;
		break;
	case CMD_WRITE_ANALOG:
		SensorValue[pinId] = writeVal;
		break;
	case CMD_WRITE_MOTOR:
		motor[pinId] = writeVal;
	}
}

void error(char* message, int val)
{
	errorTime = nSysTime;
	SensorValue[red] = 1;
	writeDebugStreamLine(message, val);
}

void error(char* message)
{
	error(message, 0);
}

int parseArgs()
{
	int args = 0;
	byte num = 0;

	for (int i = 1; i < 24 && commandBuffer[i] != CMD_END; i ++)
	{
		byte b = commandBuffer[i];

		if (b == CMD_SPLIT)
		{
			argBuffer[args++] = num;
			num = 0;
		} else if (b >= '0' && b <= '9')
		{
			// ASCII for '0' is 48
			byte converted = b - '0';
			num *= 10;
			num += converted;
		} else
			error("Unrecognized value while parsing: ", b);
	}

	argBuffer[args++] = num;
	return args;
}

void handleCommand()
{
	int args = parseArgs();
	byte cmd = commandBuffer[0];

	switch (cmd)
	{
	case CMD_WRITE_ANALOG:
	case CMD_WRITE_DIGITAL:
	case CMD_WRITE_MOTOR:
		if (args == 2)
			commitWrite(cmd, argBuffer[0], argBuffer[1]);
		else
			error("Unexpected number of arguments: ", args);
		break;
	default:
		error("Unrecognized command number: ", cmd);
	}
}

void handleByte(byte val)
{
	switch (val)
	{
	case MSG_END:
		if (commandPointer > 0)
			error("Message ended without command end");
		else
			break;
	case CMD_END:
		commandBuffer[commandPointer] = CMD_END;
		handleCommand();
		commandPointer = 0;
		break;

	default:
		commandBuffer[commandPointer++] = val;
	}
}

task WaitForCommands()
{
	while (true)
	{
		char rx = getChar(uartTwo);
		if (rx != 255)
			handleByte(rx);
	}
}

task main()
{
	while (getChar(uartTwo) != -1)
	{}

	startTask(SendSensorValues);
	startTask(WaitForCommands);

	while (true)
	{
		wait1Msec(500);
		SensorValue[green] = 1 - SensorValue[green];
		if (nSysTime - errorTime > 10000)
			SensorValue[red] = 0;
	}
}
