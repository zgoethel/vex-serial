#pragma config(UART_Usage, UART2, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(Sensor, dgtl1,  benMobile,      sensorRotation)
#pragma config(Sensor, dgtl5,  wings,          sensorQuadEncoder)
#pragma config(Sensor, dgtl10, green,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, yellow,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, red,            sensorLEDtoVCC)
#pragma config(Motor,  port5,           ben,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ANALOG_COUNT                8
#define ANALOG_START                0

#define DIGITAL_COUNT               12
#define DIGITAL_START               dgtl1

#define MOTOR_COUNT                 10
#define MOTOR_START                 0

#define CMD_END                     ';'
#define CMD_SPLIT                   ','
#define MSG_END                     '\n'
#define CMD_WRITE_ANALOG            'A'
#define CMD_WRITE_DIGITAL           'D'
#define CMD_WRITE_MOTOR             'M'

long sensorValues   [48] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
long motors         [10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0       };
char commandBuffer  [24] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
char argBuffer      [6]	 = { 0, 0, 0, 0, 0, 0                   };

long errorTime = 0;
int commandPointer = 0;

void writeChar(char c)
{
	sendChar(uartTwo, c);
	//while (!bXmitComplete(uartTwo));
}

void writeChars(char* c)
{
	string s;
	stringFromChars(s, c);

	for (int i = 0; i < strlen(s); i ++)
		writeChar(stringGetChar(s, i));
}

void writeLine(char* c)
{
	writeChars(c);
	writeChar('\n');
}

// Inbuilt pow(a, b) function returns 10^2 = 99
int power(int a, int b)
{
	int n = 1;
	for (int i = 0; i < b; i ++)
		n *= a;
	return n;
}

void writeNumber(long num)
{
	if (num < 0)
	{
		writeChar('-');
		num *= -1;
	} else if (num == 0)
	{
		writeChar('0');
		return;
	}

	int chars = log10(num);
	bool f = num > 100;

	for (int i = chars; i >= 0; i --)
	{
		int base = power(10, i);
		int n = num / base;
		writeChar(n + '0');
		num -= base * n;
	}
}

void writeSensorUpdate(char* name, long* arr, int s, int c)
{
	writeChars(name);
	writeChar(':');

	for (int i = s; i < s + c; i ++)
	{
		writeNumber(arr[i]);
		if (i < s + c - 1)
			writeChar(',');
	}

	writeLine(";");
}

task SendSensorValues()
{
	while (true)
	{
		for (int i = 0; i < 48; i ++)
			sensorValues[i] = SensorValue[i];
		writeSensorUpdate("A", &sensorValues[0], ANALOG_START, ANALOG_COUNT);
		writeSensorUpdate("D", &sensorValues[0], DIGITAL_START, DIGITAL_COUNT);
		for (int i = 0; i < 10; i ++)
			motors[i] = motor[i];
		writeSensorUpdate("M", motors, MOTOR_START, MOTOR_COUNT);
		wait1Msec(20);
	}
}

void commitWrite(char typeId, char pinId, char writeVal)
{
	switch (typeId)
	{
	case CMD_WRITE_DIGITAL:
		SensorValue[dgtl1 + pinId] = writeVal;
		break;
	case CMD_WRITE_ANALOG:
		SensorValue[pinId] = writeVal;
		break;
	case CMD_WRITE_MOTOR:
		motor[pinId] = writeVal - 128;
	}
}

void error(char* message, int val)
{
	errorTime = nSysTime;
	SensorValue[red] = 1;
	writeDebugStreamLine(message, val);
}

void error(char* message)
{
	error(message, 0);
}

int parseArgs()
{
	int args = 0;
	long num = 0;

	for (int i = 1; i < 24 && commandBuffer[i] != CMD_END; i ++)
	{
		char b = commandBuffer[i];

		if (b == CMD_SPLIT)
		{
			argBuffer[args++] = num;
			num = 0;
		} else if (b >= '0' && b <= '9')
		{
			// ASCII for '0' is 48
			char converted = b - '0';
			num *= 10;
			num += converted;
		} else
			error("Unrecognized value while parsing: %d", b);
	}

	argBuffer[args++] = num;
	return args;
}

void handleCommand()
{
	int args = parseArgs();
	char cmd = commandBuffer[0];

	switch (cmd)
	{
	case CMD_WRITE_ANALOG:
	case CMD_WRITE_DIGITAL:
	case CMD_WRITE_MOTOR:
		if (args == 2)
			commitWrite(cmd, argBuffer[0], argBuffer[1]);
		else
			error("Unexpected number of arguments: %d", args);
		break;
	default:
		error("Unrecognized command number: %d", cmd);
	}
}

void handleChar(char val)
{
	switch (val)
	{
	case MSG_END:
		if (commandPointer > 0)
			error("Message ended without command end");
		else
			break;
	case CMD_END:
		commandBuffer[commandPointer] = CMD_END;
		handleCommand();
		commandPointer = 0;
		break;

	default:
		commandBuffer[commandPointer++] = val;
		if (commandPointer == 23)
			handleChar(MSG_END);
	}
}

task WaitForCommands()
{
	while (true)
	{
		char rx = getChar(uartTwo);
		if (rx != 255)
			handleChar(rx);
	}
}

task main()
{
	while (getChar(uartTwo) != -1)
	{}

	startTask(SendSensorValues);
	startTask(WaitForCommands);

	while (true)
	{
		wait1Msec(500);
		SensorValue[green] = 1 - SensorValue[green];
		if (nSysTime - errorTime > 10000)
			SensorValue[red] = 0;
	}
}
